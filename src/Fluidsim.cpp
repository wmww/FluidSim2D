#include "FluidSim.h"#include "Particle.h"#include "ShapeLoader.h"//int dnsty[HGHT][WDTH];Voxel area[HGHT][WDTH];int cycle=0;int prtclsNum=0; //number of recorded particlesPrtcl *frstPrtcl=0;ClsnEdge *frstClsnEdge=0;int clsnEdgeCycles=0; //the number of cycles since collision edge force has been resetObject obj[MAX_OBJ];int objNum=0;void updtSim();void calcObjFrc();void init(){	//int i;	int x, y;		frstPrtcl=0;		cout << "setting up voxel map" << endl;		for (x=0; x<WDTH; ++x)	{		for (y=0; y<HGHT; ++y)		{			area[y][x].d=0;			area[y][x].dx=0;			area[y][x].dy=0;						area[y][x].dAvg=0;			area[y][x].dxAvg=0;			area[y][x].dyAvg=0;		}	}		cout << "setting up object" << endl;		ShapeLoader loader("test_shape");		if (BOX_EDGES[0])		addClsnEdge(0.5, 0.5, 0.5, HGHT-0.5);		if (BOX_EDGES[1])		addClsnEdge(WDTH-0.5, 0.5, WDTH-0.5, HGHT-0.5);		if (BOX_EDGES[2])		addClsnEdge(0.5, 0.5, WDTH-0.5, 0.5);		if (BOX_EDGES[3])		addClsnEdge(0.5, HGHT-0.5, WDTH-0.5, HGHT-0.5);		//setCloseToEdge();		/*PlygnBuilder obj;		for (i=0; i<24; ++i)	{		obj.addVert(WDTH/2+cos(grdnt(i, 0, 24, 0, 2*PI))*HGHT/4, HGHT/2+sin(grdnt(i, 0, 24, 0, 2*PI))*HGHT/4);	}		obj.finish();*/		//obj0.xNew[8]=obj0.xNew[7]+HGHT/12;	//obj0.yNew[8]=HGHT/2;		//obj0.xNew[9]=obj0.xNew[10];	//obj0.yNew[9]=HGHT/2;		//obj0.xNew[12]=WDTH/2;	//obj0.yNew[12]=HGHT/2;		/*obj0.xNew[0]=xObj+0;	obj0.yNew[0]=yObj+HGHT/8;	obj0.xNew[1]=xObj-HGHT/32;	obj0.yNew[1]=yObj+HGHT/32;		obj0.xNew[2]=xObj-HGHT/8;	obj0.yNew[2]=yObj+0;	obj0.xNew[3]=xObj-HGHT/32;	obj0.yNew[3]=yObj-HGHT/32;		obj0.xNew[4]=xObj+0;	obj0.yNew[4]=yObj-HGHT/8;	obj0.xNew[5]=xObj+HGHT/32;	obj0.yNew[5]=yObj-HGHT/32;		obj0.xNew[6]=xObj+HGHT/8;	obj0.yNew[6]=yObj+0;	obj0.xNew[7]=xObj+HGHT/32;	obj0.yNew[7]=yObj+HGHT/32;*/		Prtcl *ptr;	int i;		for (i=0; i<(WDTH-INIT_DX)*HGHT*STRT_DNSTY; ++i)	{		ptr=new Prtcl(drand(INIT_DX+0.5, WDTH-0.5), drand(0.5, HGHT-0.5), INIT_DX, INIT_DY);				if (ptr->isInObj())			delete ptr;	}}void base (){	Prtcl *ptr;	int i;		for (i=0; i<INIT_DX*HGHT*STRT_DNSTY; ++i)	{		ptr=new Prtcl(drand(0.5, INIT_DX+0.5), drand(0.5, HGHT-0.5), INIT_DX, INIT_DY);				if (ptr->isInObj())			delete ptr;	}		/*{		for (i=0; i<200*STRT_DNSTY; ++i)		{			new Prtcl(drand(0.5, 48), drand(0.5, HGHT-0.5), INIT_DX, INIT_DY);		}	}*/		if (!USE_AVG_DRAG)		resetClsnEdgeFrc();		updtSim();		clsnEdgeCycles++;		calcObjFrc();}void updtSim(){	Prtcl *ptr, *nxt;		ptr=frstPrtcl;		while (ptr)	{		ptr->dxOld=ptr->dx;		ptr->dyOld=ptr->dy;				//note: prtclFrctnEffct() uses particles speed so order does matter		ptr->prtclFrctnEffct();		ptr->dnstyEffct();		ptr->rndmEffct();				ptr=ptr->nxt;	}		ptr=frstPrtcl;		while (ptr)	{		nxt=ptr->nxt;				--area[(int)ptr->y][(int)ptr->x].d;		area[(int)ptr->y][(int)ptr->x].dx-=ptr->dxOld;		area[(int)ptr->y][(int)ptr->x].dy-=ptr->dyOld;				ptr->x+=ptr->dx;		ptr->y+=ptr->dy;				ptr->clsnEdgeEffct();				if (!ptr->isInArea())			delete ptr;					else		{			++area[(int)ptr->y][(int)ptr->x].d;			area[(int)ptr->y][(int)ptr->x].dx+=ptr->dx;			area[(int)ptr->y][(int)ptr->x].dy+=ptr->dy;						++area[(int)ptr->y][(int)ptr->x].dAvg;			area[(int)ptr->y][(int)ptr->x].dxAvg+=ptr->dx;			area[(int)ptr->y][(int)ptr->x].dyAvg+=ptr->dy;		}						ptr=nxt;	}}void addClsnEdge(double x1, double y1, double x2, double y2){	ClsnEdge *edge;		edge=new ClsnEdge;		edge->nxt=frstClsnEdge;		frstClsnEdge=edge;		edge->x1=x1;	edge->y1=y1;		edge->x2=x2;	edge->y2=y2;		edge->bbl=min(x1, x2);	edge->bbr=max(x1, x2);	edge->bbb=min(y1, y2);	edge->bbt=max(y1, y2);		edge->xf=0;	edge->yf=0;}void addObj(ClsnEdge *frst, int edgeNum){	obj[objNum].frstEdge=frst;	obj[objNum].edges=edgeNum;		obj[objNum].bbl=frst->x1;	obj[objNum].bbr=frst->x1;	obj[objNum].bbb=frst->y1;	obj[objNum].bbt=frst->y1;		ClsnEdge *ptr=obj[objNum].frstEdge;		for (int i=0; i<obj[objNum].edges; ++i)	{		obj[objNum].bbl=min(obj[objNum].bbl, ptr->x2);		obj[objNum].bbr=max(obj[objNum].bbr, ptr->x2);		obj[objNum].bbb=min(obj[objNum].bbb, ptr->y2);		obj[objNum].bbt=max(obj[objNum].bbt, ptr->y2);				ptr=ptr->nxt;	}		objNum++;}void resetClsnEdgeFrc(){	ClsnEdge *ptr;		ptr=frstClsnEdge;		while (ptr)	{		ptr->xf=0;		ptr->yf=0;				ptr=ptr->nxt;	}		clsnEdgeCycles=0;}void calcObjFrc(){	int i, j;	ClsnEdge *ptr;		for (i=0; i<objNum; ++i)	{		obj[i].xf=0;		obj[i].yf=0;				ptr=obj[i].frstEdge;				for(j=0; j<obj[i].edges; ++j)		{			obj[i].xf+=ptr->xf;			obj[i].yf+=ptr->yf;			ptr=ptr->nxt;		}				obj[i].xf/=clsnEdgeCycles;		obj[i].yf/=clsnEdgeCycles;				obj[i].drag=(2*obj[i].xf)/(INIT_DX*STRT_DNSTY*(obj[i].bbt-obj[i].bbb));				cout << endl << "object " << i << " drag: " << obj[i].drag << endl;	}		cout << endl;}