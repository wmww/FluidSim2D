#include "Particle.h"//bool closeToEdge[HGHT][WDTH];Prtcl::Prtcl(double xPos, double yPos, double xDlta, double yDlta, bool addToArea){	int xLoc, yLoc;		xPos=clamp(xPos, 0.5, WDTH+0.5);	yPos=clamp(yPos, 0.5, HGHT+0.5);		xLoc=xPos; yLoc=yPos;		x=xPos;	y=yPos;		dx=xDlta;	dy=yDlta;		dxOld=0;	dyOld=0;		if (addToArea)	{		nxt=frstPrtcl;		if (nxt)			nxt->prv=this;		frstPrtcl=this;		prv=0;				area[yLoc][xLoc].d++;		area[yLoc][xLoc].dx+=dx;		area[yLoc][xLoc].dy+=dy;		prtclsNum++;	}	else	{		prv=0;		nxt=0;	}		//dxAvg=0;	//dyAvg=0;		//xStrt=x;	//yStrt=y;		//if (frstPrtcl)		//frstPrtcl->prv=this;			//prv=0;		//color=clr(255, (int)grdnt(x, 0, WDTH, 0, 256*6)%256, 0);//256-(int)grdnt(y, 0, HGHT, 0, 256*6)%256);		/*if (!cycle)		color=clr(128, 255, 0);	else		color=clr(255, 0, 128);*/}Prtcl::~Prtcl(){	//searches for particle without using prv (very slow)	/*Prtcl *prv;		if (this==frstPrtcl)		frstPrtcl=nxt;	else	{		prv=frstPrtcl;				while (prv->nxt!=this)			prv=prv->nxt;				prv->nxt=nxt;	}*/			if (prv || nxt || frstPrtcl==this) //only do this action if this is part of the particle list	{		if (x>=0 && x<WDTH && y>=0 && y<HGHT)		{			area[int(y)][int(x)].d--;			area[int(y)][int(x)].dx-=dx;			area[int(y)][int(x)].dy-=dy;		}				if (prv)			prv->nxt=nxt;		else			frstPrtcl=nxt;				if (nxt)			nxt->prv=prv;				prtclsNum--;	}}void Prtcl::rndmEffct(){	dx+=drand(-RNDM_MV, RNDM_MV);	dy+=drand(-RNDM_MV, RNDM_MV);}void Prtcl::prtclFrctnEffct(){	int xLoc, yLoc;	double dxLoc, dyLoc; //the average delta at the current location		xLoc=clamp(x, 0, WDTH-1);	yLoc=clamp(y, 0, HGHT-1);		if (area[yLoc][xLoc].d)	{		dxLoc=area[yLoc][xLoc].dx/area[yLoc][xLoc].d;		dyLoc=area[yLoc][xLoc].dy/area[yLoc][xLoc].d;				dx+=(dxLoc-dx)*PRTCL_FRCTN;		dy+=(dyLoc-dy)*PRTCL_FRCTN;	}}void Prtcl::dnstyEffct(){	int xPos, yPos; //position of the lower left pixel	double xSub, ySub; //sub location within pixel (0-1)	int lDnsty, rDnsty, bDnsty, tDnsty; //left, right, top and bottom density		xPos=clamp(int(x-0.5), 0, WDTH-2);	yPos=clamp(int(y-0.5), 0, HGHT-2);		xSub=x-xPos-0.5;	ySub=y-yPos-0.5;		lDnsty=area[yPos+1][xPos+0].d*(ySub)+area[yPos+0][xPos+0].d*(1-ySub);	rDnsty=area[yPos+1][xPos+1].d*(ySub)+area[yPos+0][xPos+1].d*(1-ySub);	bDnsty=area[yPos+0][xPos+1].d*(xSub)+area[yPos+0][xPos+0].d*(1-xSub);	tDnsty=area[yPos+1][xPos+1].d*(xSub)+area[yPos+1][xPos+0].d*(1-xSub);		dx+=(lDnsty-rDnsty)*DNSTY_FORCE;	dy+=(bDnsty-tDnsty)*DNSTY_FORCE;}void Prtcl::clsnEdgeEffct(double prvClsnTme, ClsnEdge *prvClsnEdge, int rcrsn) //receives the time (0-1) the previous collision occurred and what edge that was with. also, what level of recursion we are on{	ClsnEdge *edge;	double t=0; //the time of the intersection; 0 is current time, 1 is last cycle	double p; //the position on the line the particle collides with; 0 is vert 1, 1 is vert 2	double xf1, xo1, yf1, yo1; //parametric constants of particle motion (x and y factor and offset) (x=t*xf+xo, y=t*yf+yo)	double xf2, xo2, yf2, yo2; //parametric constants of line (x and y factor and offset) (x=t*xf+xo, y=t*yf+yo)	double exf=0, exo=0, eyf=1, eyo=1; //e stands for edge, only set when collision is detected	double frstClsnTme=1; //the time of the first collision (only includes collisions that happen after the last handled collision) (0 is last cycle, 1 is this cycle)	bool clsn=0; //if there is an unhandled collision (a handled collision would be one that a previous recursion has handled and if we did it again would result in the particle going the wrong way	double dnmtr; //the denominator	double xFlipPoint, yFlipPoint; //used for calculating reflections	ClsnEdge *edgeOfFrstClsn=0;	double bbl, bbr, bbb, bbt; //the bounding box of this particles movement (used to not try to detect collisions with edges that are not in range)		//if (x>0 && x<WDTH && y>0 && y<HGHT)		//if (!closeToEdge[(int)y][(int)x])			//return;		edge=frstClsnEdge;		bbl=min(x, x-dx);	bbr=max(x, x-dx);	bbb=min(y, y-dy);	bbt=max(y, y-dy);		while (edge)	{		if (bbl<edge->bbr &&			bbr>edge->bbl &&			bbb<edge->bbt &&			bbt>edge->bbb &&			edge!=prvClsnEdge)		{			xo1=x-dx;			yo1=y-dy;			xf1=dx;			yf1=dy;						//set the constants for the linear parametric equation of the current edge			xo2=edge->x1; 			yo2=edge->y1;			xf2=edge->x2-xo2;			yf2=edge->y2-yo2;						//set the denominator of the equation we will use in a moment (we do this to make sure it's not zero			dnmtr=(yf2*xf1-yf1*xf2);						if (dnmtr) //if denominator is zero the lines are parallel and there is no collision			{				t=(xf2*(yo1-yo2)+yf2*(xo2-xo1))/dnmtr; //<-- this line of code took and hour of work and weeks of thought to write								if (t>=prvClsnTme && t<=1)				{					p=(xf1*(yo2-yo1)+yf1*(xo1-xo2))/(yf1*xf2-yf2*xf1);										if (p>=0 && p<=1)					{						clsn=1;												if (t<=frstClsnTme)						{							edgeOfFrstClsn=edge;							frstClsnTme=t;							exo=xo2;							eyo=yo2;							exf=xf2;							eyf=yf2;						}					}				}			}		}				edge=edge->nxt;	}		if (clsn)	{		//make t be the position along the line that is (perpendicular to the edge) and (runs through the particle)		t=(exf*(y-eyo)+eyf*(exo-x))/(eyf*eyf+exf*exf);				//use the t we just set to find (the closest point (on the edge to the particle))		xFlipPoint=t*eyf;		yFlipPoint=-t*exf;				x+=xFlipPoint*(1+OBJ_BOUNCE);		y+=yFlipPoint*(1+OBJ_BOUNCE);				t=(exf*(dy)+eyf*(-dx))/(eyf*eyf+exf*exf);				xFlipPoint=t*eyf;		yFlipPoint=-t*exf;				edgeOfFrstClsn->xf-=xFlipPoint;		edgeOfFrstClsn->yf-=yFlipPoint;				dx+=xFlipPoint*(1+OBJ_BOUNCE);		dy+=yFlipPoint*(1+OBJ_BOUNCE);				rcrsn+=1;				if (rcrsn<MAX_ITRTN)			clsnEdgeEffct(frstClsnTme, edgeOfFrstClsn, rcrsn);		else			cout << ">> particle ran out of allowed recursions <<" << endl;	}}bool Prtcl::isInObj(){	int i, j;	ClsnEdge *ptr;	int below;		for (i=0; i<objNum; ++i)	{		ptr=obj[i].frstEdge;		below=0;				for (j=0; j<obj[i].edges; ++j)		{			if ((x>ptr->x1 && x<ptr->x2) || (x<ptr->x1 && x>ptr->x2))				if (y>grdnt(x, ptr->x1, ptr->x2, ptr->y1, ptr->y2))					below++;						ptr=ptr->nxt;		}				if (below%2==1)			return 1;	}		return 0;}/*void setCloseToEdge(){	int x, y;	ClsnEdge *ptr;	int yFactor;		Image lineImage(WDTH, HGHT); //we use an image to draw lines to		lineImage.clrFill(clr(0, 0, 0));		ptr=frstClsnEdge;		while (ptr)	{		lineImage.line(ptr->x1, ptr->y1, ptr->x2, ptr->y2, MAX_STABLE_PTRCL_SPD, clr(255, 255, 255));		ptr=ptr->nxt;	}		for (y=0; y<HGHT; ++y)	{		yFactor=y*WDTH;				for (x=0; x<WDTH; ++x)		{			closeToEdge[y][x]=(lineImage.bits[x+yFactor].r>128);		}	}}*/